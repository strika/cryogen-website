<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>There are ants on the page</title><link href="http://nebojsa.stricevic.info/atom.xml" rel="self" /><link href="http://nebojsa.stricevic.info" /><updated></updated><id>http://nebojsa.stricevic.info</id><author><name>@nstricevic</name></author><entry><title>Clojure Syntax - From Empty List To Macros</title><link>http://nebojsa.stricevic.info/2014/07/clojure-syntax.html</link><updated>2014-07-14T00:00:00</updated><id>http://nebojsa.stricevic.info/2014/07/clojure-syntax.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Few months ago I gave a talk at &lt;a href=&quot;http://renderedtext.com/blog/2013/12/19/ctrl-flow-notes/&quot;&gt;Ctrl+Flow&lt;/a&gt;, a local hackers metup organized by &lt;a href=&quot;http://renderedtext.com&quot;&gt;Rendered Text&lt;/a&gt;. I'm writing the core of the talk here for memory and future reference.&lt;/p&gt;&lt;h2&gt;Clojure Syntax&lt;/h2&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defn- fib-iter
  [max n i j]
  (if (= n max)
    j
    (recur max
           (inc n)
           j
           (+ i j))))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;One of the most repealing properties of Clojure for newcomers is it's syntax. If you didn't have an exposure to a Lisp before, it looks fairly alien with all the parenthesis. Our goal here is to discover where does the syntax comes from and why is it so different from other languages out there.&lt;/p&gt;&lt;h2&gt;Clojure Reader&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;First, let's introduce a character.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;img alt=&quot;Robot image, representing Clojure Reader&quot; src=&quot;http://robohash.org/Strika&quot; /&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;The friendly looking robot is Clojure Reader. He's job is similar like interpreters in other languages &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;. You give him a piece of code, it executes it and returns you the result. But there is one significant difference. While other interpreters eat lines of code - Clojure Reader eats lists!&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;So the first thing to learn from Clojure Syntax is the simplest, most basic list - an empty list:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;()&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Two characters, in it's glory - an open parenthesis and a closed parenthesis.&lt;/p&gt;&lt;h2&gt;Lists Represent Code&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Let's try to add a two numbers with Clojure. Since Clojure Reader eats lists, you need construct a list with 3 items - a + sign, a number and another number.&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(+ 1 2)
3&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;And Clojure Reader will happily return 3. It works. Let's try more:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(- 5 1)
4

(+ 1 2 3)
6&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;We can already see a pattern here. If you want the Clojure Reader to execute a function, you construct a list where first item of the list is the function and other items of the list are arguments to the function. An interesting thing to note is that + and - are just regular functions that can accept more than 2 arguments.&lt;/p&gt;&lt;h2&gt;Lists of Lists of Lists&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Let's examine a more complex arithmetic expression:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(* (- 12 8) (+ 1 2))
12&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Clojure evaluates complex expressions in steps:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(* (- 12 8) (+ 1 2))
(* 4 (+ 1 2))
(* 4 3)
12&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;As with most modern programming languages, Clojure first evaluates a function arguments and then the function itself.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;As we saw before, + and - are just functions. They are not operators. And there are no operator precedence in Clojure. It's not needed. Parenthesis are not used to group expressions, but to create lists to be executed.&lt;/p&gt;&lt;h2&gt;Variables and Functions&lt;/h2&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def a 3)
(def b 4)
(+ a b)
7&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;To define a variable in Clojure you should construct a list where first item of the list is a keyword &lt;em&gt;def&lt;/em&gt;, followed by the variable name, followed by the variable value.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Variables can also hold functions:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def add-2
  (fn [n]
    (+ n 2)))

(add-2 7)
9&lt;/pre&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def more-than-5?
  (fn [n]
    (if (&amp;gt; n 5)
      &amp;quot;YES&amp;quot;
      &amp;quot;NO&amp;quot;)))

(more-than-5? 10)
&amp;quot;YES&amp;quot;&lt;/pre&gt;&lt;h2&gt;Lists For Collections&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Of course, lists can be used for more than code. They can also hold &lt;em&gt;just&lt;/em&gt; data. But, creating a list of numbers with what we learned so far may end up unexpectedly:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def numbers (1 2 3 4 5))
Error! There is no function &amp;quot;1&amp;quot;.&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;The problem is that Clojure follows a hard rule - it will try to execute a first item of a list as it were a function. You need to tell Clojure not to execute a list with ' operator.&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def numbers '(1 2 3 4 5))

(count numbers)
5

(first numbers)
1

(rest numbers)
(2 3 4 5)

(map add-2 numbers)
(3 4 5 6 7)&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;In the last example, the &lt;em&gt;map&lt;/em&gt; function executes the &lt;em&gt;add-2&lt;/em&gt; function on all items of &lt;em&gt;numbers&lt;/em&gt;.&lt;/p&gt;&lt;h2&gt;What Can You Put In a List?&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Clojure is a dynamically typed language so lists can hold different types. It's interesting that a list can hold some unexpected stuff too:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def some-code '(+ 1 2))

(first some-code)
+

(rest some-code)
(1 2)

(eval some-code)
3

(def new-code
  (cons '-
        (rest some-code)))

(println new-code)
(- 1 2)

(eval new-code)
-1&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;You can put a piece of code in a list,  play with it and execute it. In the example, we removed + from the &lt;em&gt;some-code&lt;/em&gt;, inserted - instead and created the &lt;em&gt;new-code&lt;/em&gt;.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;You may point out that a similar thing is available in Ruby, JavaScript and other languages. There, you would put a code in a string and execute it. The difference, though, is that with Clojure, you have all the functions available to work with collections to mold the code. In other languages you have only the functions that work with strings - a much less powerful set.&lt;/p&gt;&lt;h2&gt;Extending the Language&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;We already saw how &lt;em&gt;if&lt;/em&gt; in Clojure looks like:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(if (= 1 1)
  (println &amp;quot;1 is indeed 1&amp;quot;))
&amp;quot;1 is indeed 1&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Let's try to create &lt;em&gt;unless&lt;/em&gt; in Clojure:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(unless (= 1 1)
  (println &amp;quot;1 is not really 1&amp;quot;))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;We could try with a function:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def unless
  (function [condition code]
            (if (not condition)
              code)))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;What happens when we try to execute it?&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(unless (= 1 1)
  (println &amp;quot;1 is not really 1&amp;quot;))
&amp;quot;1 is not really 1&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Although the condition is true, Clojure executed the body of &lt;em&gt;unless&lt;/em&gt;. Problem is that, as we said before, Clojure first executes arguments of a function and then the function itself. This means that Clojure first executed &lt;cite&gt;(println &quot;1 is not really 1&quot;)&lt;/cite&gt; and then the &lt;em&gt;unless&lt;/em&gt; function itself. It's obvious &lt;em&gt;unless&lt;/em&gt; can't be implemented with a function.&lt;/p&gt;&lt;h2&gt;Macros&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;To implement &lt;em&gt;unless&lt;/em&gt; we need to use macros.&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defmacro unless [condition code]
  '(if (not ~condition)
     ~code))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Macros are used to transform the code and they don't execute parameters. So an &lt;em&gt;unless&lt;/em&gt; call:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(unless (= 1 1)
  (println &amp;quot;1 is not really 1&amp;quot;))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;would first be transformed to:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(if (not (= 1 1))
  (println &amp;quot;1 is not really 1&amp;quot;))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;and then executed, which would produce the desired result.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Macros allow you to define a feature - control structure, that looks like it was included in the language itself - to extend the language. Our &lt;em&gt;unless&lt;/em&gt; macro looks similar to &lt;em&gt;if&lt;/em&gt;. You can't tell it wasn't shipped with Clojure.&lt;/p&gt;&lt;h2&gt;Why Macros?&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;In 1996, Java appeared with &lt;em&gt;for&lt;/em&gt; loop. In 2004 Java received an upgraded &lt;em&gt;for-each&lt;/em&gt; loop.&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;// 1996.
for (int i = 0; i &amp;lt; collection.size(); i++) {
  SomeType var = collection.get(i);
  ...
}

// 2004.
for (SomeType var : collection) {
  ...
}&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;It took years to add the upgraded loop to Java. Is there a way you can add a similar feature to the language yourself? You would need to open the Java compiler, to learn the bytecode and to master the language Java was implemented in. With Clojure, you can implement the &lt;em&gt;for-each&lt;/em&gt; loop with a macro in just few lines of Clojure:&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defmacro foreach [[sym coll] &amp;amp; body]
  `(loop [coll# ~coll]
     (when-let [[~sym &amp;amp; xs#] (seq coll#)]
       ~@body
       (recur xs#))))

(foreach [i numbers]
         (println i))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;There are few funny looking characters in the implementation, but it's just 5 lines of code. Any devoted Clojure developer could do it.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Clojure's extensibility comes from the fact that Clojure code is made of Clojure lists. Code is data. And that's why macros can transform code into other code.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Now you know when you see a lot of parenthesis there are no reason to frown. It's just lists of lists. Data. Code.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&lt;span id=&quot;1&quot;&gt;[1] This is not really what Clojure Reader does, but for the sake of introduction to Clojure syntax, it's OK to pretend it is.&lt;/span&gt;&lt;/p&gt;</content></entry><entry><title>Rake and Rails environment</title><link>http://nebojsa.stricevic.info/2014/02/rake-and-rails-enviroment.html</link><updated>2014-02-02T00:00:00</updated><id>http://nebojsa.stricevic.info/2014/02/rake-and-rails-enviroment.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;I've been using Rake daily for more than 2 years now,
   but I never went through a proper tutorial about Rake.
   Lately, I learned few basic things about Rake that made
   task dependency much more clear.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Simplest way to define a rake task is this:&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;task :my_task do
  # do some stuff
end&lt;/pre&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;If you need to run :prepare task before :my_task, this
   is the way to do it:&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;task :my_task =&amp;gt; :prepare do
  # do some stuff
end&lt;/pre&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;And when you need to run several tasks before :my_task, you
   can use an array:&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;task :my_task =&amp;gt; [:clean, :prepare, :setup_logging] do
  # do some stuff
end&lt;/pre&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Rake is using Ruby's flexible syntax to create a comfortable DSL for writing tasks
   (that may look strange at first).&lt;/p&gt;&lt;h2&gt;Rails' :environment task&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;A special task that you probably encountered before is the :environment task:&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;task :my_task =&amp;gt; :environment do
  # do some stuff
end&lt;/pre&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;The :environment task loads the Rails' environment so all you code and gems are available
   in :my_task.&lt;/p&gt;&lt;h2&gt;When not to use :environment task&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;If you're writing a task that needs to be executed periodically, in short
   intervals and doesn't depend on lots of other code, don't use :environment task.
   Load dependencies manually instead. Running a task that depends on :environment
   can take 20-30 seconds or more since it's starting the whole Rails and loading
   all gems for the environment.&lt;/p&gt;</content></entry><entry><title>Who is John McCarthy?</title><link>http://nebojsa.stricevic.info/2014/01/john-mccarthy.html</link><updated>2014-01-05T00:00:00</updated><id>http://nebojsa.stricevic.info/2014/01/john-mccarthy.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Few years ago I was a teaching assistant on University of Novi Sad. I was teaching an introduction to software engineering and design patterns. Students were just a couple of years younger than me.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;One day I said to a class that John McCarthy died yesterday. One of students asked &quot;Who?&quot; and soon I realized that no one in the room new who John McCarthy is &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;. That made me sad. Shouldn't they know?&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;John McCarthy was computer scientist that developed Lisp programming language &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;, godfather of artificial intelligence and AI researcher. For his contributions to computer science he received many honors, including Turing Award and Kyoto Prize.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;It seams there is a shortage of computer science history classes on universities. And shortage of curiosity for the field history among students and practitioners, as well.&lt;/p&gt;&lt;p&gt;&lt;span id=&quot;1&quot;&gt;[1] &lt;a href=&quot;https://en.wikipedia.org/wiki/John_McCarthy_%28computer_scientist%29&quot;&gt;John McCarthy on Wikipedia&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span id=&quot;2&quot;&gt;[2] &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_%28programming_language%29&quot;&gt;Lisp on Wikipedia&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;</content></entry><entry><title>Maximize Firefox window in a Cucumber Selenium scenario</title><link>http://nebojsa.stricevic.info/2013/12/maximize-firefox-window-in-cucumber.html</link><updated>2013-12-27T00:00:00</updated><id>http://nebojsa.stricevic.info/2013/12/maximize-firefox-window-in-cucumber.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;This is one of those &quot;can't make this scenario pass&quot; war stories.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;The other day I was working on a piece of code that's using jQuery UI
   draggable and droppable interactions. And I just couldn't make the scenario
   pass. But I also couldn't stop working on it. One of reasons was that there was very
   similar scenario already passing.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Scenarios were using Capybara's &lt;a href=&quot;http://rubydoc.info/github/jnicklas/capybara/master/Capybara/Node/Element:drag_to&quot;&gt;#drag_to&lt;/a&gt; method that makes testing drag and drop a breeze.
   After couple of hours of debugging and moving stuff around, I saw something
   interesting in the Firefox window that runs the test - during the drag and drop
   execution scroll bar moves.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;The thing is that Firefox window was small. After drag started, small scrolling happened 
   to reveal the drop target. To make the scenario pass I had to make both the drag node and
   the drop node visible from the start.&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Final solution was to maximize Firefox window just before drag is initiated:&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;# in a step definition
page.driver.browser.manage.window.maximize&lt;/pre&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Sometimes it pays off to follow how a test is executed in a browser window.
   And for some tests you really need to start &quot;thinking&quot; like a machine to
   understand what's going on inside a test.&lt;/p&gt;</content></entry><entry><title>Hello World</title><link>http://nebojsa.stricevic.info/2013/12/hello-world.html</link><updated>2013-12-13T00:00:00</updated><id>http://nebojsa.stricevic.info/2013/12/hello-world.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Launching the site...&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;3... 2... 1...&lt;/p&gt;</content></entry></feed>